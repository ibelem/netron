<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebNN Netron - Model Weights and Biases Reader (.bin/.json)</title>
  <meta name="description" content="WebNN Netron - Model Weights and Biases Reader (.bin/.json)">
  <meta name="author" content="https://github.com/ibelem">
  <meta property="og:title" content="WebNN Netron - Model Weights and Biases Reader (.bin/.json)">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://ibelem.github.io/netron">
  <meta property="og:description" content="WebNN Netron - Model Weights and Biases Reader (.bin/.json)">
  <meta property="og:image" content="icon.png">
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
  <link rel="icon" type="image/png" href="icon.png">
  <link rel="apple-touch-icon" type="image/png" href="icon.png">
  <link rel="apple-touch-icon-precomposed" type="image/png" href="icon.png">
  <link rel="fluid-icon" type="image/png" href="icon.png">
  <style>
    /* CSS for layout and styling */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      font-size: 12px;
    }

    header {
      background-color: #f4f4f4;
      padding: 15px;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: 1.5em;
    }

    header p {
      margin: 5px 0;
      font-size: 0.9em;
      color: #555;
    }

    #main {
      display: flex;
      flex: 1;
      overflow: hidden;
      border-top: 1px solid #ddd;
    }

    #sidebar {
      width: 20%;
      background-color: #f4f4f4;
      border-right: 1px solid #ddd;
      overflow-y: auto;
    }

    #sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #sidebar li {
      padding: 4px 20px;
      cursor: pointer;
      border-bottom: 1px solid #ddd;
      font-size: 0.8rem;
    }

    #sidebar li:hover {
      background-color: #eaeaea;
    }

    #sidebar li.selected {
      background-color: #eaeaea;
    }

    #content {
      flex: 1;
      padding: 0px 20px 20px 20px;
      overflow-y: auto;
    }

    #content pre {
      background-color: #f9f9f9;
      padding: 10px;
      border: 1px solid #ddd;
      overflow-x: auto;
    }

    #upload-buttons {
      display: flex;
      justify-content: center;
      background-color: #f4f4f4;
    }

    #upload-buttons input {
      margin-right: 10px;
    }

    ul li {
      list-style: none;
    }

    #string-data {
      background-color: #f9f9f9;
      padding: 10px;
      border: 1px solid #ddd;
      font-family: monospace;
    }

    #string-header {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 1rem;
      justify-content: space-between;
    }

    #status {
      margin: 1rem 0;
    }

    #footer {
      margin: 1rem 0;
    }

    a {
      color: rgba(27, 31, 35, 1);
      text-decoration: none;
      border-bottom: 1px dashed rgba(27, 31, 35, 1);
    }

    a:hover {
      color:deeppink;
      border-bottom: 1px solid deeppink;
    }
  </style>
</head>

<body>
  <header>
    <h1>WebNN Netron - Model Weights and Biases Reader (.bin/.json)</h1>
    <div id="status">
      <ul>
        <li>Upload .json and .bin files (generated by <a href="https://ibelem.github.io/netron/">WebNN Netron</a>) to view the model weight and bias data</li>
        <li>Use the URL parameters <code>?json=json_url&bin=bin_url</code> to load files directly</li>
      </ul>
    </div>
    <div id="upload-buttons">
      <div>
        <label for="json-upload">Upload JSON:</label>
        <input type="file" id="json-upload" accept=".json">
      </div>
      <div>
        <label for="bin-upload">Upload BIN:</label>
        <input type="file" id="bin-upload" accept=".bin">
      </div>
    </div>
  </header>
  <div id="main">
    <div id="sidebar">
      <ul id="key-list">
        <!-- JSON keys will be dynamically added here -->
      </ul>
    </div>
    <div id="content">
      <div id="info">
        <h2>Details</h2>
        <pre id="details"></pre>
      </div>
      <div id="arraybuffer">
        <h2>ArrayBuffer Data</h2>
        <pre id="buffer-data"></pre>
      </div>
      <div id="string">
        <div id="string-header">
          <h2>String Data</h2>
          <div>
            <label for="data-limit">Show:</label>
            <select id="data-limit">
              <option value="100" selected>100</option>
              <option value="200">200</option>
              <option value="500">500</option>
              <option value="1000">1000</option>
              <option value="2000">2000</option>
              <option value="5000">5000</option>
              <option value="10000">10000</option>
              <option value="unlimited">Unlimited</option>
            </select>
          </div>
        </div>
        <div id="string-data"></div>
      </div>
      <div id="footer">&copy;2025 <a href="https://ibelem.github.io/netron/">WebNN Neutron</a> · <a href="https://github.com/ibelem/netron/issues">GitHub Issues</a> · <a href="https://ibelem.github.io/netron/reader.html?json=https://ibelem.github.io/netron/webnn/model_20250429081302.json&bin=https://ibelem.github.io/netron/webnn/model_20250429081302.bin">Example</a></a></div>
    </div>
  </div>

  <script>
    // JavaScript for handling file uploads and URL parameters
    const $ = s => document.querySelector(s);

    const keyList = $('#key-list');
    const details = $('#details');
    const bufferData = $('#buffer-data');
    const stringData = $('#string-data');
    const jsonUpload = $('#json-upload');
    const binUpload = $('#bin-upload');
    const statusElement = $('#status');

    let jsonData = null;
    let binData = null;

    // Function to fetch files from URL parameters
    async function fetchFilesFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const jsonUrl = params.get('json');
      const binUrl = params.get('bin');

      if (jsonUrl && binUrl) {
        try {
          const [jsonResponse, binResponse] = await Promise.all([
            fetch(jsonUrl).then(res => res.json()),
            fetch(binUrl).then(res => res.arrayBuffer())
          ]);
          jsonData = jsonResponse;
          binData = binResponse;
          populateSidebar();
        } catch (error) {
          console.error('Error fetching files from URL:', error);
        }
      }
    }

    // Function to populate the sidebar with JSON keys
    function populateSidebar() {
      if (!jsonData) return;

      keyList.innerHTML = '';
      Object.keys(jsonData).forEach(key => {
        const li = document.createElement('li');
        li.textContent = `${key}`;
        li.title = `${jsonData[key].node} · ${jsonData[key].input}`;
        li.addEventListener('click', () => {
          // Remove the 'selected' class from all list items
          document.querySelectorAll('#key-list li').forEach(item => item.classList.remove('selected'));
          // Add the 'selected' class to the clicked item
          li.classList.add('selected');
          displayDetails(key);
        });
        keyList.appendChild(li);
      });
    }

    // Function to display details and ArrayBuffer data
    function displayDetails(key) {
      if (!jsonData || !binData) return;

      const info = jsonData[key];
      details.textContent = JSON.stringify(info, null, 2);

      const { dataOffset, byteLength, dataType } = info;

      // Display raw buffer data
      const buffer = new Uint8Array(binData, dataOffset, byteLength);
      bufferData.textContent = Array.from(buffer).join(', ');

      // Interpret the data based on dataType
      let interpretedData;
      try {
        switch (dataType.toUpperCase()) {
          case 'FLOAT':
          case 'FLOAT32':
          case 1:
            interpretedData = new Float32Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'UINT8':
          case 2:
            interpretedData = new Uint8Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'INT8':
          case 3:
            interpretedData = new Int8Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'UINT16':
          case 4:
            interpretedData = new Uint16Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'INT16':
          case 5:
            interpretedData = new Int16Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'INT32':
          case 6:
            interpretedData = new Int32Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'INT64':
          case 7:
            if (typeof BigInt64Array !== 'undefined') {
              interpretedData = new BigInt64Array(binData.slice(dataOffset, dataOffset + byteLength));
            } else {
              interpretedData = "Int64 data type not fully supported in this browser";
            }
            break;
          case 'STRING':
          case 8:
            interpretedData = new TextDecoder().decode(
              new Uint8Array(binData.slice(dataOffset, dataOffset + byteLength))
            );
            break;
          case 'BOOL':
          case 9:
            interpretedData = new Uint8Array(binData.slice(dataOffset, dataOffset + byteLength))
              .map(value => Boolean(value));
            break;
          case 'FLOAT16':
          case 10:
            interpretedData = new Float16Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'DOUBLE':
          case 11:
            interpretedData = new Float64Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'UINT32':
          case 12:
            interpretedData = new Uint32Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'UINT64':
          case 13:
            if (typeof BigUint64Array !== 'undefined') {
              interpretedData = new BigUint64Array(binData.slice(dataOffset, dataOffset + byteLength));
            } else {
              interpretedData = "Uint64 data type not fully supported in this browser";
            }
            break;
          default:
            interpretedData = "Unknown data type: " + dataType;
        }

        // Get the selected data limit
        const dataLimitSelect = $('#data-limit');
        const selectedLimit = dataLimitSelect.value === 'unlimited' ? interpretedData.length : parseInt(dataLimitSelect.value, 10);

        // Display the data based on the selected limit
        let displayData = Array.from(interpretedData.slice(0, selectedLimit)).join(', ');
        if (interpretedData.length > selectedLimit) {
          displayData += '... (truncated, showing ' + selectedLimit + ' of ' + interpretedData.length + ' values)';
        }
        stringData.textContent = displayData;

      } catch (error) {
        stringData.textContent = "Error interpreting data: " + error.message;
      }
    }

    // Event listeners for file uploads
    jsonUpload.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file) {
        jsonData = await file.text().then(JSON.parse);
        populateSidebar();
      }
    });

    binUpload.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file) {
        try {
          binData = await file.arrayBuffer();
          statusElement.textContent = `Binary file loaded: ${file.name} (${formatBytes(binData.byteLength)})`;
        } catch (error) {
          statusElement.textContent = `Error loading binary file: ${error.message}`;
          binData = null;
        }
      }
    });

    // Helper function to format bytes to readable format
    function formatBytes(bytes, decimals = 2) {
      if (bytes === 0) return '0 Bytes';

      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];

      const i = Math.floor(Math.log(bytes) / Math.log(k));

      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    // Initialize by checking URL parameters
    fetchFilesFromUrl();

    // Event listener for the data-limit dropdown
    $('#data-limit').addEventListener('change', () => {
      // Get the currently selected key in the sidebar
      const selectedKey = document.querySelector('#key-list li.selected');
      if (selectedKey) {
        displayDetails(selectedKey.textContent);
      }
    });
  </script>
</body>

</html>