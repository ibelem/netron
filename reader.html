<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebNN Netron - Model Weights and Biases Reader (.bin/.json)</title>
  <meta name="description" content="WebNN Netron - Weights and Biases Reader (.bin/.json)">
  <meta name="author" content="https://github.com/ibelem">
  <meta property="og:title" content="WebNN Netron - Weights and Biases Reader (.bin/.json)">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://ibelem.github.io/netron">
  <meta property="og:description" content="WebNN Netron - Weights and Biases Reader (.bin/.json)">
  <meta property="og:image" content="icon.png">
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
  <link rel="icon" type="image/png" href="icon.png">
  <link rel="apple-touch-icon" type="image/png" href="icon.png">
  <link rel="apple-touch-icon-precomposed" type="image/png" href="icon.png">
  <link rel="fluid-icon" type="image/png" href="icon.png">
  <style>
    :root {
      --primary-color: #007bff;
      --primary-dark: #0056b3;
      --background-light: #f4f4f4;
      --border-color: #ddd;
      --text-color: #333;
      --text-secondary: #555;
    }
    
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      font-size: 12px;
    }

    header {
      background-color: #f4f4f4;
      padding: 15px;
      text-align: center;
    }

    header h1 {
      margin: 0;
      font-size: 1.5em;
    }

    header p {
      margin: 5px 0;
      font-size: 0.9em;
      color: #555;
    }

    #main {
      display: flex;
      flex: 1;
      overflow: hidden;
      border-top: 1px solid #ddd;
    }

    #sidebar {
      width: 20%;
      background-color: #f4f4f4;
      border-right: 1px solid #ddd;
      overflow-y: auto;
    }

    #sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #sidebar li {
      padding: 4px 20px;
      cursor: pointer;
      border-bottom: 1px solid #ddd;
      font-size: 0.8rem;
    }

    #sidebar li:hover {
      background-color: #eaeaea;
    }

    #sidebar li.selected {
      background-color: #eaeaea;
    }

    #content {
      flex: 1;
      padding: 0px 20px 20px 20px;
      overflow-y: auto;
    }

    #content pre {
      background-color: #f9f9f9;
      padding: 10px;
      border: 1px solid #ddd;
      overflow-x: auto;
    }

    .upload-container {
      display: flex;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .file-input-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .file-input-label {
      background-color: var(--primary-color);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .file-input-label:hover {
      background-color: var(--primary-dark);
    }

    input[type="file"] {
      display: none;
    }

    .file-name {
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    select {
      padding: 5px 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: white;
    }

    ul li {
      list-style: none;
    }

    #string-data {
      background-color: #f9f9f9;
      padding: 10px;
      border: 1px solid #ddd;
      font-family: monospace;
    }

    #string-header {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 1rem;
      justify-content: space-between;
    }

    #status {
      margin: 1rem 0;
    }

    #footer {
      margin: 1rem 0;
    }

    a {
      color: rgba(27, 31, 35, 1);
      text-decoration: none;
      border-bottom: 1px dashed rgba(27, 31, 35, 1);
    }

    a:hover {
      color: deeppink;
      border-bottom: 1px solid deeppink;
    }

    button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 10px 15px;
      cursor: pointer;
      border-radius: 5px;
    }

    button:hover {
      background-color: #0056b3;
    }

    #loading {
      font-size: 1.2em;
      color: #555;
      text-align: center;
      margin: 20px 0;
    }
  </style>
</head>

<body>
  <header>
    <h1>WebNN Netron - Weights and Biases Reader (.bin/.json)</h1>
    <div id="status">
      <ul>
        <li>Upload .json and .bin files (generated by <a href="https://ibelem.github.io/netron/">WebNN Netron</a>) to
          view the model weight and bias data</li>
        <li>Use the URL parameters <code>?json=json_url&bin=bin_url</code> to load files directly</li>
      </ul>
    </div>
    <div class="upload-container">
      <div class="file-input-group">
        <label for="json-upload" class="file-input-label">Choose JSON File</label>
        <input type="file" id="json-upload" accept=".json">
        <span class="file-name" id="json-file-name">No file selected</span>
      </div>
      <div class="file-input-group">
        <label for="bin-upload" class="file-input-label">Choose BIN File</label>
        <input type="file" id="bin-upload" accept=".bin">
        <span class="file-name" id="bin-file-name">No file selected</span>
      </div>
    </div>
  </header>
  <div id="main">
    <div id="sidebar">
      <ul id="key-list">
        <!-- JSON keys will be dynamically added here -->
      </ul>
    </div>
    <div id="content">
      <div id="info">
        <h2>Details</h2>
        <pre id="details"></pre>
      </div>
      <div id="arraybuffer">
        <h2>ArrayBuffer Data</h2>
        <pre id="buffer-data"></pre>
      </div>
      <div id="string">
        <div id="string-header">
          <h2>String Data</h2>
          <div>
            <label for="data-limit">Show:</label>
            <select id="data-limit">
              <option value="1" selected>1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="unlimited">Unlimited</option>
            </select>
          </div>
        </div>
        <div id="string-data"></div>
      </div>
      <div id="footer">&copy;2025 <a href="https://ibelem.github.io/netron/">WebNN Netron</a> 路 <a
          href="https://github.com/ibelem/netron/issues">GitHub Issues</a> 路 
          <a href="https://ibelem.github.io/webnn-code-generator/">WebNN Code Generator</a> 路 <a
          href="https://ibelem.github.io/netron/reader.html?json=https://ibelem.github.io/netron/model/mobilenetv2-12-static/model_weights_bias_20250520014112.json&bin=https://ibelem.github.io/netron/model/mobilenetv2-12-static/model_20250520014112.bin">Example</a></a>
      </div>
    </div>
  </div>
  <div id="loading" style="display: none;">Loading...</div>

  <script>
    // JavaScript for handling file uploads and URL parameters
    const $ = s => document.querySelector(s);

    const keyList = $('#key-list');
    const details = $('#details');
    const bufferData = $('#buffer-data');
    const stringData = $('#string-data');
    const jsonUpload = $('#json-upload');
    const binUpload = $('#bin-upload');
    const statusElement = $('#status');

    let jsonData = null;
    let binData = null;

    // Function to fetch files from URL parameters
    async function fetchFilesFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const jsonUrl = params.get('json');
      const binUrl = params.get('bin');

      if (jsonUrl && binUrl) {
        try {
          const [jsonResponse, binResponse] = await Promise.all([
            fetch(jsonUrl).then(res => res.json()),
            fetch(binUrl).then(res => res.arrayBuffer())
          ]);
          jsonData = jsonResponse;
          binData = binResponse;
          populateSidebar();
        } catch (error) {
          console.error('Error fetching files from URL:', error);
        }
      }
    }

    // Function to populate the sidebar with JSON keys
    function populateSidebar() {
      if (!jsonData) return;

      keyList.innerHTML = '';
      Object.keys(jsonData).forEach(key => {
        const li = document.createElement('li');
        li.textContent = `${key}`;
        li.title = `${jsonData[key].node} 路 ${jsonData[key].input}`;
        li.addEventListener('click', () => {
          // Remove the 'selected' class from all list items
          document.querySelectorAll('#key-list li').forEach(item => item.classList.remove('selected'));
          // Add the 'selected' class to the clicked item
          li.classList.add('selected');
          displayDetails(key);
        });
        keyList.appendChild(li);
      });
    }

    // Function to display details and ArrayBuffer data
    function displayDetails(key) {
      if (!jsonData || !binData) return;

      const info = jsonData[key];
      details.textContent = JSON.stringify(info, null, 2);

      const { dataOffset, byteLength, dataType, shape } = info;

      // Display raw buffer data
      const buffer = new Uint8Array(binData, dataOffset, byteLength);
      bufferData.textContent = Array.from(buffer).join(', ');

      // Interpret the data based on dataType
      let interpretedData;
      try {
        switch (dataType.toUpperCase()) {
          case 'FLOAT':
          case 'FLOAT32':
          case 1:
            interpretedData = new Float32Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'UINT8':
          case 2:
            interpretedData = new Uint8Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'INT8':
          case 3:
            interpretedData = new Int8Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'UINT16':
          case 4:
            interpretedData = new Uint16Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'INT16':
          case 5:
            interpretedData = new Int16Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'INT32':
          case 6:
            interpretedData = new Int32Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'INT64':
          case 7:
            if (typeof BigInt64Array !== 'undefined') {
              interpretedData = new BigInt64Array(binData.slice(dataOffset, dataOffset + byteLength));
            } else {
              interpretedData = "Int64 data type not fully supported in this browser";
            }
            break;
          case 'STRING':
          case 8:
            interpretedData = new TextDecoder().decode(
              new Uint8Array(binData.slice(dataOffset, dataOffset + byteLength))
            );
            break;
          case 'BOOL':
          case 9:
            interpretedData = new Uint8Array(binData.slice(dataOffset, dataOffset + byteLength))
              .map(value => Boolean(value));
            break;
          case 'FLOAT16':
          case 10:
            interpretedData = new Float16Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'DOUBLE':
          case 11:
            interpretedData = new Float64Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'UINT32':
          case 12:
            interpretedData = new Uint32Array(binData.slice(dataOffset, dataOffset + byteLength));
            break;
          case 'UINT64':
          case 13:
            if (typeof BigUint64Array !== 'undefined') {
              interpretedData = new BigUint64Array(binData.slice(dataOffset, dataOffset + byteLength));
            } else {
              interpretedData = "Uint64 data type not fully supported in this browser";
            }
            break;
          default:
            interpretedData = "Unknown data type: " + dataType;
        }

        let updatedShape = shape;
        if (!shape || !Array.isArray(shape) || shape.length === 0) {
          updatedShape = [1];
        }

        if (!interpretedData || interpretedData.length === 0) {
          stringData.textContent = "Error: No data available to interpret.";
          return;
        }

        // Display the reshaped data
        const dataLimitSelect = $('#data-limit');

        const selectedLimit = dataLimitSelect.value === 'unlimited' ? interpretedData.length : parseInt(dataLimitSelect.value, 10);
        let updatedShapeLength;

        if (selectedLimit === 'unlimited') {
          updatedShapeLength = interpretedData.length;
        } else {
          // Handle the selected limit (1-4) to determine how many dimensions to include
          const dimensionsToUse = Math.min(selectedLimit, updatedShape.length);

          if (dimensionsToUse === 0) {
            // No dimensions in shape, default to length of the data
            updatedShapeLength = interpretedData.length;
          } else {
            // Calculate product of the first N dimensions based on dimensionsToUse
            updatedShapeLength = 1;
            for (let i = 0; i < dimensionsToUse; i++) {
              if (updatedShape[i]) {
                updatedShapeLength *= updatedShape[i];
              }
            }
          }

          // Ensure the calculated length doesn't exceed the data we have
          updatedShapeLength = Math.min(updatedShapeLength, interpretedData.length);
        }

        let expectedInterpretedData = Array.from(interpretedData.slice(0, updatedShapeLength));

        // Reshape the data based on the shape
        const reshapedData = reshapeArray(expectedInterpretedData, updatedShape);
        if (interpretedData.length > updatedShapeLength) {
          stringData.textContent = JSON.stringify(reshapedData, (key, value) =>
            typeof value === 'bigint' ? Number(value) : value, 2)
            + '... (truncated, showing ' + updatedShapeLength + ' of ' + interpretedData.length + ' values)';
        } else {
          stringData.textContent = JSON.stringify(reshapedData, (key, value) =>
            typeof value === 'bigint' ? Number(value) : value, 2);
        }

      } catch (error) {
        stringData.textContent = "Error interpreting data: " + error.message;
      }
    }

    // Event listeners for file uploads
    jsonUpload.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file && file.type === 'application/json') {
        jsonData = await file.text().then(JSON.parse);
        populateSidebar();
      } else {
        alert('Please upload a valid JSON file.');
      }
    });

    binUpload.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file && file.type === 'application/octet-stream') {
        binData = await file.arrayBuffer();
        statusElement.textContent = `Binary file loaded: ${file.name} (${formatBytes(binData.byteLength)})`;
      } else {
        alert('Please upload a valid BIN file.');
      }
    });

    // Helper function to format bytes to readable format
    function formatBytes(bytes, decimals = 2) {
      if (bytes === 0) return '0 Bytes';

      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];

      const i = Math.floor(Math.log(bytes) / Math.log(k));

      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    // Function to reshape array based on shape
    function reshapeArray(data, shape) {
      if (shape.length === 0) return data; // Base case for scalar values

      const [dim, ...rest] = shape; // Extract the first dimension and the remaining dimensions
      const chunkSize = rest.length > 0 ? rest.reduce((a, b) => a * b, 1) : 1; // Calculate the size of each chunk
      const reshaped = [];

      for (let i = 0; i < data.length; i += chunkSize) {
        if (rest.length === 0) {
          reshaped.push(data[i]); // Push scalar values directly
        } else {
          reshaped.push(reshapeArray(data.slice(i, i + chunkSize), rest)); // Recursively reshape the remaining dimensions
        }
      }

      return reshaped;
    }

    function calculateTotalElements(shape) {
      return shape.reduce((product, dimension) => product * dimension, 1);
    }

    function showLoading() {
      $('#loading').style.display = 'block';
    }

    function hideLoading() {
      $('#loading').style.display = 'none';
    }

    // Initialize by checking URL parameters
    showLoading();
    fetchFilesFromUrl().finally(hideLoading);

    // Event listener for the data-limit dropdown
    $('#data-limit').addEventListener('change', () => {
      // Get the currently selected key in the sidebar
      const selectedKey = document.querySelector('#key-list li.selected');
      if (selectedKey) {
        displayDetails(selectedKey.textContent);
      }
    });

    document.addEventListener('DOMContentLoaded', () => {
      const dataLimitSelect = $('#data-limit');
      if (dataLimitSelect) {
        dataLimitSelect.addEventListener('change', () => {
          const selectedKey = document.querySelector('#key-list li.selected');
          if (selectedKey) {
            displayDetails(selectedKey.textContent);
          }
        });
      }
    });

    keyList.addEventListener('keydown', (event) => {
      const selected = document.querySelector('#key-list li.selected');
      if (event.key === 'ArrowDown') {
        const next = selected?.nextElementSibling;
        if (next) {
          selected.classList.remove('selected');
          next.classList.add('selected');
          displayDetails(next.textContent);
        }
      } else if (event.key === 'ArrowUp') {
        const prev = selected?.previousElementSibling;
        if (prev) {
          selected.classList.remove('selected');
          prev.classList.add('selected');
          displayDetails(prev.textContent);
        }
      }
    });
  </script>
</body>

</html>